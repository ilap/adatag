use aiken/bytearray
use ilap/labeled_tree/hash.{combine_three_hashes, hash_val}
use ilap/labeled_tree/types.{Hash, HashNode, NodeHash, Proof, Val}

// blake2b_224
pub const empty_hash =
  #[0x83,
    0x6c,
    0xc6,
    0x89,
    0x31,
    0xc2,
    0xe4,
    0xe3,
    0xe8,
    0x38,
    0x60,
    0x2e,
    0xca,
    0x19,
    0x02,
    0x59,
    0x1d,
    0x21,
    0x68,
    0x37,
    0xba,
    0xfd,
    0xdf,
    0xe6,
    0xf0,
    0xc8,
    0xcb,
    0x07,
  ]

// sha2_256
// pub const empty_hash =  #[0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14, 0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24, 0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c, 0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,]

/// 
/// The `append_nodes` is a function that creates the updated append nodes from the
/// two nodes (update and append node) that will be modified (updated and appended) in the tree
/// during the insertion of an element.
/// 
/// The function takes a `ByteArray`, an update node (`nu`), an append node (`na`),
/// and an index (`idx`). It returns a tuple containing the updated update node,
/// the updated append node, and the new leaf for insertion.
/// 
fn append_nodes(
  x: ByteArray,
  idx: ByteArray,
  nuv: Val,
  nav: Val,
) -> (Val, Val, Val) {
  if
  bytearray.compare(nuv.xa, x) == Less && bytearray.compare(x, nuv.xb) == Less{
  
    let u = Val { xi: nuv.xi, xa: nuv.xa, xb: x }
    let l = Val { xi: idx, xa: x, xb: nuv.xb }
    let a =
      if nuv == nav {
        nuv
      } else {
        nav
      }
    (u, a, l)
  } else {
    fail
  }
}

///  
/// The `append_check` is a function designed to validate the correctness of a tree after an insertion.
///
/// It takes the following inputs:
///   1. The element being inserted (as a `ByteArray`).
///   2. The size (or index) of the tree (required for enforcing the completeness of the tree).
///   3. The old root hash of the tree before insertion.
///   4. The updated root hash of the tree after insertion.
///   5. The value of the update node in the tree before insertion.
///   6. The value of the append node in the tree before insertion.
///   7. A proof, represented by a minimal subtree containing the two nodes whose values are used,
///      validating the insertion operation.
///
/// The function checks two scenarios:
///   a. When `False` is passed to the `checkProof`, it validates the root hash before insertion.
///   b. When `True` is passed to the `checkProof`, it validates the root hash of the tree after insertion.
///
/// Therefore the `append_check` verifies the integrity of a tree by confirming that:
///   - The two nodes' values are present in the proof (a minimal subtree of the tree).
///   - The old root hash can be regenerated using the values of the update and append nodes and the provided proof.
///   - The updated root hash can be regenerated by modifying these nodes based on the passed element and using the same proof tree.
///
/// This function is used to prove that an element has been inserted into the tree, with the old root hash representing the state before insertion
/// and the updated root hash representing the state after insertion.
///
/// This allows users to securely prove that they've successfully inserted the specified element into the tree.
///
/// The function returns `True` if both scenarios pass; otherwise, it returns `False`.
///
/// > Note: The tsize and the old root hash is a public value derived from previous operations and cannot be manipulated.
/// > Also, the element and the values must be checked before passing to the append_check function.
///
/// Brief: Function to validate the correctness of a tree after an insertion
///
pub fn append_check(
  e: ByteArray,
  t_size: ByteArray,
  root: Hash,
  updated_root: Hash,
  nuv: Val,
  nav: Val,
  proof: Proof,
) -> Bool {
  let nuh = hash_val(nuv)
  let nah = hash_val(nav)
  let nodes = append_nodes(x: e, idx: t_size, nuv: nuv, nav: nav)

  check_proof(False, root, proof, nuh, nah, nodes) && check_proof(
    True,
    updated_root,
    proof,
    nuh,
    nah,
    nodes,
  )
}

/// Brief: Function to check the correctness of a proof
fn check_proof(
  is_new_state: Bool,
  root: Hash,
  proof: Proof,
  nuh: Hash,
  nah: Hash,
  nodes: (Val, Val, Val),
) -> Bool {
  let (has_nu, has_na, calculated_root) =
    validate_proof(
      is_new_state: is_new_state,
      has_nu: False,
      has_na: False,
      node: proof,
      nuh: nuh,
      nah: nah,
      nodes: nodes,
    )
  has_nu && has_na && calculated_root == root
}

/// Brief: Recursive function to validate a proof
pub fn validate_proof(
  is_new_state: Bool,
  has_nu: Bool,
  has_na: Bool,
  node: Proof,
  nuh: Hash,
  nah: Hash,
  nodes: (Val, Val, Val),
) -> (Bool, Bool, Hash) {
  when node is {
    NodeHash { hash } -> (has_nu, has_na, hash)
    HashNode { hash, left, right } -> {
      let enu = hash == nuh
      let ena = hash == nah

      let has_nu = has_nu || ena
      let has_na = has_na || enu

      let (lnu, lna, lh) =
        validate_proof(
          is_new_state: is_new_state,
          has_nu: has_nu,
          has_na: has_na,
          node: left,
          nuh: nuh,
          nah: nah,
          nodes: nodes,
        )
      let (rnu, rna, rh) =
        validate_proof(
          is_new_state: is_new_state,
          has_nu: has_nu,
          has_na: has_na,
          node: right,
          nuh: nuh,
          nah: nah,
          nodes: nodes,
        )
      let is_any = enu || ena

      if is_new_state && is_any {
        let (nuv, nav, leaf) = nodes
        let nvh =
          if enu {
            hash_val(nuv)
          } else {
            hash_val(nav)
          }
        let leaf_h =
          combine_three_hashes(hash_val(leaf), empty_hash, empty_hash)
        let (nlh, nrh) =
          if lh == empty_hash {
            (leaf_h, rh)
          } else {
            (lh, leaf_h)
          }

        (lnu || rnu, lna || rna, combine_three_hashes(nvh, nlh, nrh))
      } else {
        (lnu || rnu, lna || rna, combine_three_hashes(hash, lh, rh))
      }
    }
  }
}
