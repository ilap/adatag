use aiken/bytearray
use ilap/integri_tree/hash.{combine_three_hashes, empty_hash, hash_val}
use ilap/integri_tree/types.{Hash, HashNode, NodeHash, Proof, Val}

/// 
/// The `append_values` is a function that creates the required 3 values from the
/// two nodes' (update and append node) that will be modified (updated and appended) in the tree
/// during the insertion of an element.
/// 
/// The function takes a `ByteArray`, an update node (`nu`), an append node (`na`),
/// and an index (`idx`). It returns a tuple containing the updated update node,
/// the updated append node, and the new leaf for insertion.
/// 
fn append_values(
  x: ByteArray,
  idx: ByteArray,
  nuv: Val,
  nav: Val,
) -> (Val, Val, Val) {
  if
  bytearray.compare(nuv.xa, x) == Less && bytearray.compare(x, nuv.xb) == Less{
  
    let u = Val { xi: nuv.xi, xa: nuv.xa, xb: x }
    let l = Val { xi: idx, xa: x, xb: nuv.xb }
    let a =
      if nuv == nav {
        u
      } else {
        nav
      }
    (u, a, l)
  } else {
    fail
  }
}

///  
/// The `append_check` is a function designed to validate the correctness of a tree after an insertion.
///
/// It takes the following inputs:
///   1. The element being inserted (as a `ByteArray`).
///   2. The size (or index) of the tree (required for enforcing the completeness of the tree).
///   3. The old root hash of the tree before insertion.
///   4. The updated root hash of the tree after insertion.
///   5. The value of the update node in the tree before insertion.
///   6. The value of the append node in the tree before insertion.
///   7. A proof, represented by a minimal subtree containing the two nodes whose values are used,
///      validating the insertion operation.
///
/// The function checks two scenarios:
///   a. When `False` is passed to the `checkProof`, it validates the root hash before insertion.
///   b. When `True` is passed to the `checkProof`, it validates the root hash of the tree after insertion.
///
/// Therefore the `append_check` verifies the integrity of a tree by confirming that:
///   - The two nodes' values are present in the proof (a minimal subtree of the tree).
///   - The old root hash can be regenerated using the values of the update and append nodes and the provided proof.
///   - The updated root hash can be regenerated by modifying these nodes based on the passed element and using the same proof tree.
///
/// This function is used to prove that an element has been inserted into the tree, with the old root hash representing the state before insertion
/// and the updated root hash representing the state after insertion.
///
/// This allows users to securely prove that they've successfully inserted the specified element into the tree.
///
/// The function returns `True` if both scenarios pass; otherwise, it returns `False`.
///
/// > Note: The tsize and the old root hash is a public value derived from previous operations and cannot be manipulated.
/// > Also, the element and the values must be checked before passing to the append_check function.
///
/// Brief: Function to validate the correctness of a tree after an insertion
///
pub fn append_check(
  e: ByteArray,
  t_size: ByteArray,
  root: Hash,
  updated_root: Hash,
  nuv: Val,
  nav: Val,
  proof: Proof,
) -> Bool {
  let nuh = hash_val(nuv)
  let nah = hash_val(nav)
  let nodes = append_values(x: e, idx: t_size, nuv: nuv, nav: nav)

  check_proof(False, root, proof, nuh, nah, nodes) && check_proof(
    True,
    updated_root,
    proof,
    nuh,
    nah,
    nodes,
  )
}

/// Brief: Function to check the correctness of a proof
///
/// To ensure the integrity of a tree the following conditions must be met at inserting elements:
/// - the appendable node right child must be an empty hash.
/// - if the left child is an empty hash the size of the tree must be:
///    - when size != number of nodes (i.e. initial tree has 1 noded but the size of tree is 0): an.xi * 2 + 1
///    - when size == nr of node: an.xi * 2
///
/// Meaning, the tree size is always != element in the tree as the tree with no element (except the lower- and upper bounds)
/// - tree size: number of nodes in the tree.
/// - nr of elements: tree size - 1
fn check_proof(
  is_new_state: Bool,
  root: Hash,
  proof: Proof,
  nuh: Hash,
  nah: Hash,
  nodes: (Val, Val, Val),
) -> Bool {
  let (has_nu, has_na, calculated_root) =
    validate_proof(
      is_new_state: is_new_state,
      has_nu: False,
      has_na: False,
      node: proof,
      nuh: nuh,
      nah: nah,
      nodes: nodes,
    )
  has_nu && has_na && calculated_root == root
}

/// The proof must contain the update node and the append node and the calulated root hash
/// must be 
/// Brief: Recursive function to validate a proof
pub fn validate_proof(
  is_new_state: Bool,
  has_nu: Bool,
  has_na: Bool,
  node: Proof,
  nuh: Hash,
  nah: Hash,
  nodes: (Val, Val, Val),
) -> (Bool, Bool, Hash) {
  when node is {
    NodeHash { hash } -> (has_nu, has_na, hash)
    HashNode { hash, left, right } -> {
      let enu = hash == nuh
      let ena = hash == nah

      let has_nu = has_nu || enu
      let has_na = has_na || ena

      let (lnu, lna, lh) =
        validate_proof(
          is_new_state: is_new_state,
          has_nu: has_nu,
          has_na: has_na,
          node: left,
          nuh: nuh,
          nah: nah,
          nodes: nodes,
        )
      let (rnu, rna, rh) =
        validate_proof(
          is_new_state: is_new_state,
          has_nu: has_nu,
          has_na: has_na,
          node: right,
          nuh: nuh,
          nah: nah,
          nodes: nodes,
        )

      // This node is either the update or append node and we calculate the new
      // state by update the current nodes by the generated ones.
      if is_new_state && ( enu || ena ) {
        let (nuv, nav, leaf) = nodes

        let (nvh, nlh, nrh) =
          // Append and update nodes are the same
          if nuv == nav || ena {
            let leaf_h =
              combine_three_hashes(hash_val(leaf), empty_hash, empty_hash)
            let (al, ar) =
              // The only valid combination to ensure the integrity of the tree are:
              // 1. left and right are emtpy hashes
              // 2. left is not empty and right is empty
              // otherwise invalid.
              if lh == empty_hash && rh == empty_hash {
                (leaf_h, rh)
              } else if lh != empty_hash && rh == empty_hash {
                (lh, leaf_h)
              } else {
                // The right must always be an empty hash constraints above are not met
                fail
              }
            (hash_val(nav), al, ar)
          } else if enu {
            // Only the val is changed
            (hash_val(nuv), lh, rh)
          } else {
            // Impossible happened
            fail
          }

        (lnu || rnu, lna || rna, combine_three_hashes(nvh, nlh, nrh))
      } else {
        (lnu || rnu, lna || rna, combine_three_hashes(hash, lh, rh))
      }
    }
  }
}
